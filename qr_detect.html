<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>QR Detect (iPhone)</title>
<style>
  body { font-family: -apple-system, system-ui, sans-serif; margin: 0; padding: 16px; }
  header { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; }
  #video { width: 100%; max-height: 45vh; background:#000; border-radius: 8px; }
  #canvas { display:none; }
  .stats { display:flex; gap:16px; flex-wrap:wrap; font-size:14px; color:#444; }
  .stat { background:#f5f5f7; padding:8px 12px; border-radius:8px; }
  .row { margin-top:12px; }
  button { padding:8px 12px; border:1px solid #ccc; border-radius:8px; background:white; }
  .ok { color:#0a7; }
  .warn { color:#d73; }
  .err { color:#d33; }
  code { background:#f0f0f0; padding:2px 4px; border-radius:4px; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
</style>
</head>
<body>
  <header>
    <h2 style="margin:0">iPhone QR Detect</h2>
    <button id="toggle">▶ 시작</button>
  </header>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div class="row stats">
    <div class="stat">FPS: <span id="fps">0</span></div>
    <div class="stat">성공률: <span id="rate">0</span>%</div>
    <div class="stat">평균 지연: <span id="lat">0</span> ms</div>
    <div class="stat">윈도 길이: <span id="win">5</span> s</div>
  </div>

  <div class="row" style="font-size:13px; color:#666">
    화면에 보이는 QR에서 <code>TS=</code> 타임스탬프를 읽어 현재 시각과 차이로 지연(ms)을 계산합니다. 네트워크 전송 없음.
  </div>

  <!-- jsQR: 순수 JS QR 디코더 -->
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
  <script>
  // iPhone Safari 친화적 카메라 접근 및 jsQR 기반 디코딩
  const $video = document.getElementById('video');
  const $canvas = document.getElementById('canvas');
  const $fps = document.getElementById('fps');
  const $rate = document.getElementById('rate');
  const $lat = document.getElementById('lat');
  const $win = document.getElementById('win');
  const $toggle = document.getElementById('toggle');

  let running = false;
  let stream = null;
  let ctx = null;
  let lastFrameTime = 0;
  let successCount = 0;
  let totalCount = 0;
  let latencySamples = [];
  const windowSec = 5; // 통계 윈도 길이(초)
  $win.textContent = String(windowSec);

  function resetStats() {
    successCount = 0;
    totalCount = 0;
    latencySamples = [];
    $fps.textContent = '0';
    $rate.textContent = '0';
    $lat.textContent = '0';
  }

  async function startCamera() {
    // iPhone 후면 카메라 우선 시도
    const constraints = {
      audio: false,
      video: {
        facingMode: { ideal: 'environment' },
        width: { ideal: 1280 },
        height: { ideal: 720 }
      }
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    $video.srcObject = stream;
    await $video.play();
    // 캔버스 초기화
    $canvas.width = $video.videoWidth;
    $canvas.height = $video.videoHeight;
    ctx = $canvas.getContext('2d');
  }

  function parseTimestamp(text) {
    // 형식: TS=169xxx;S=.... 또는 TS=169xxx 형태도 허용
    const m = /TS\s*=\s*(\d{10,20})/.exec(text);
    if (!m) return null;
    try { return parseInt(m[1], 10); } catch { return null; }
  }

  function updateStats(now) {
    // FPS 계산
    if (lastFrameTime) {
      const dt = (now - lastFrameTime) / 1000;
      const fps = dt > 0 ? (1 / dt) : 0;
      $fps.textContent = fps.toFixed(1);
    }
    lastFrameTime = now;

    const rate = totalCount ? (100 * successCount / totalCount) : 0;
    $rate.textContent = rate.toFixed(1);

    const avgLat = latencySamples.length ? (latencySamples.reduce((a,b)=>a+b,0) / latencySamples.length) : 0;
    $lat.textContent = avgLat.toFixed(1);
  }

  function pushLatencySample(ms, nowEpochMs) {
    // 최근 windowSec 초만 유지
    const cutoff = nowEpochMs - windowSec * 1000;
    latencySamples.push({ t: nowEpochMs, v: ms });
    latencySamples = latencySamples.filter(s => s.t >= cutoff);
  }

  function drawBox(location) {
    if (!location) return;
    ctx.strokeStyle = '#00d084';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(location.topLeftCorner.x, location.topLeftCorner.y);
    ctx.lineTo(location.topRightCorner.x, location.topRightCorner.y);
    ctx.lineTo(location.bottomRightCorner.x, location.bottomRightCorner.y);
    ctx.lineTo(location.bottomLeftCorner.x, location.bottomLeftCorner.y);
    ctx.closePath();
    ctx.stroke();
  }

  function loop(now) {
    if (!running) { requestAnimationFrame(loop); return; }
    if (!$video.videoWidth) { requestAnimationFrame(loop); return; }

    // 프레임 캡처
    ctx.drawImage($video, 0, 0, $canvas.width, $canvas.height);
    const img = ctx.getImageData(0, 0, $canvas.width, $canvas.height);
    const result = jsQR(img.data, img.width, img.height, { inversionAttempts: 'dontInvert' });

    totalCount += 1;
    if (result && result.data) {
      successCount += 1;
      // 박스 시각화
      drawBox(result.location);
      // TS 파싱 및 지연 계산
      const ts = parseTimestamp(result.data);
      if (ts) {
        const nowMs = Date.now();
        const latency = Math.max(0, nowMs - ts);
        pushLatencySample(latency, nowMs);
      }
    }

    updateStats(now);
    requestAnimationFrame(loop);
  }

  async function start() {
    if (running) return;
    resetStats();
    await startCamera();
    running = true;
    $toggle.textContent = '⏸︎ 정지';
  }

  function stop() {
    running = false;
    $toggle.textContent = '▶ 시작';
    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
  }

  $toggle.addEventListener('click', async () => {
    if (!running) { try { await start(); } catch (e) { alert('카메라 권한이 필요합니다: ' + e); } }
    else { stop(); }
  });

  // iOS: 사용자 제스처 필요로 자동재생 안 되므로 수동 시작
  requestAnimationFrame(loop);
  </script>
</body>
</html>

